`problem.py` の中で注目すべきは、 `e` の値が3と小さいことと、各要素のビット長に対する制約です。

```
assert 2046 < n.bit_length()
assert 375 == flag.bit_length()
...
print("c =", pow(flag, e, n))
```

`375 * e < 2046` なので、 `pow` 計算時に剰余の計算がされないことがわかります。

よって、 `c` の３乗根を丁寧に文字列に復元してやって終了です。
