`problem.py` をよく読むと、 `cipher` と `key` の bit-and (`&`) を取っている事がわかります。

ただし、`random.random`を利用して、bit-and計算はビットごとに 1/2 の確率で行っているようです。

便宜上、この計算を 確率的bit-and と呼ぶことにします。

真理値表を書くと、

| c | k | and(n > m) | and(n <= m) |
| -- | -- | -- | -- |
| 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 |
| 0 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 |


確率的bit-and を同じflagに対して16回行った結果が用意されているので、

高い確率で、全てのビットの `and(n > m)` の値と `and(n <= m)` の値を両方とも得る事ができます。


同じく真理値表から、 `and(n > m) | and(n <= m)` とすると `c` の値が復元できる事がわかるので、
愚直にbit-orをしてあげればflag取得となります。
